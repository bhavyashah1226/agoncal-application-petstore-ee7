// ********RoostGPT********
/*
Test generated by RoostGPT for test pomXmlTest using AI Type Open AI and AI Model gpt-4

Scenario 1: Valid InjectionPoint
Given that a valid InjectionPoint object is provided as input to the produceLogger function, the test should verify that the Logger object returned by the function correctly corresponds to the class of the InjectionPoint.

Scenario 2: Null InjectionPoint
Given that a null object is passed as an InjectionPoint to the produceLogger function, the test should verify that the function properly handles this null input, possibly by throwing an appropriate exception or returning a default logger.

Scenario 3: InjectionPoint with No Declaring Class
Given that the InjectionPoint object provided as input does not have a declaring class (for example, if it's a root level class), the test should verify that the function correctly handles this case, possibly by returning a Logger for the default package.

Scenario 4: InjectionPoint with Nested Declaring Class
Given an InjectionPoint object that comes from a nested or inner class, the test should verify that the returned Logger correctly corresponds to the full name of the nested class, including the parent class name.

Scenario 5: Multiple Calls with Same InjectionPoint
Given multiple calls to produceLogger with the same InjectionPoint, the test should verify that the Logger returned by each call is the same, as loggers for the same class should be the same object.

Scenario 6: Multiple Calls with Different InjectionPoints
Given multiple calls to produceLogger with different InjectionPoints, the test should verify that the Logger returned by each call is different, as they should correspond to different classes.

Scenario 7: InjectionPoint from Anonymous Class
Given an InjectionPoint that originates from an anonymous class, the test should verify that the Logger returned by the function correctly corresponds to this anonymous class, possibly by having a class name that includes an anonymous class identifier.
*/

// ********RoostGPT********
package org.agoncal.application.petstore.util;

import javax.enterprise.inject.spi.InjectionPoint;
import java.util.logging.Logger;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnitRunner;
import java.lang.reflect.Member;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotEquals;
import static org.mockito.Mockito.when;

@RunWith(MockitoJUnitRunner.class)
public class LoggingProducer_produceLogger_0dae710c17_Test {

    @Mock
    private InjectionPoint injectionPoint;

    @Mock
    private Member member;

    @Test
    public void testProduceLogger_validInjectionPoint() {
        when(injectionPoint.getMember()).thenReturn(member);
        when(member.getDeclaringClass()).thenReturn(LoggingProducer.class);

        LoggingProducer loggingProducer = new LoggingProducer();
        Logger logger = loggingProducer.produceLogger(injectionPoint);

        assertEquals(LoggingProducer.class.getName(), logger.getName());
    }

    @Test(expected = NullPointerException.class)
    public void testProduceLogger_nullInjectionPoint() {
        LoggingProducer loggingProducer = new LoggingProducer();
        loggingProducer.produceLogger(null);
    }

    @Test
    public void testProduceLogger_noDeclaringClass() {
        when(injectionPoint.getMember()).thenReturn(member);
        when(member.getDeclaringClass()).thenReturn(null);

        LoggingProducer loggingProducer = new LoggingProducer();
        Logger logger = loggingProducer.produceLogger(injectionPoint);

        assertEquals("", logger.getName());
    }

    @Test
    public void testProduceLogger_nestedDeclaringClass() {
        class Nested {}

        when(injectionPoint.getMember()).thenReturn(member);
        when(member.getDeclaringClass()).thenReturn(Nested.class);

        LoggingProducer loggingProducer = new LoggingProducer();
        Logger logger = loggingProducer.produceLogger(injectionPoint);

        assertEquals(Nested.class.getName(), logger.getName());
    }

    @Test
    public void testProduceLogger_sameInjectionPoint() {
        when(injectionPoint.getMember()).thenReturn(member);
        when(member.getDeclaringClass()).thenReturn(LoggingProducer.class);

        LoggingProducer loggingProducer = new LoggingProducer();
        Logger logger1 = loggingProducer.produceLogger(injectionPoint);
        Logger logger2 = loggingProducer.produceLogger(injectionPoint);

        assertEquals(logger1, logger2);
    }

    @Test
    public void testProduceLogger_differentInjectionPoints() {
        class Different {}

        when(injectionPoint.getMember()).thenReturn(member);
        when(member.getDeclaringClass()).thenReturn(LoggingProducer.class);

        InjectionPoint differentInjectionPoint = Mockito.mock(InjectionPoint.class);
        Member differentMember = Mockito.mock(Member.class);

        when(differentInjectionPoint.getMember()).thenReturn(differentMember);
        when(differentMember.getDeclaringClass()).thenReturn(Different.class);

        LoggingProducer loggingProducer = new LoggingProducer();
        Logger logger1 = loggingProducer.produceLogger(injectionPoint);
        Logger logger2 = loggingProducer.produceLogger(differentInjectionPoint);

        assertNotEquals(logger1, logger2);
    }

    @Test
    public void testProduceLogger_anonymousClass() {
        when(injectionPoint.getMember()).thenReturn(member);
        when(member.getDeclaringClass()).thenReturn(new Object(){}.getClass());

        LoggingProducer loggingProducer = new LoggingProducer();
        Logger logger = loggingProducer.produceLogger(injectionPoint);

        assertEquals(true, logger.getName().contains("$"));
    }
}
