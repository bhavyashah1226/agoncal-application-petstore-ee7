// ********RoostGPT********
/*
Test generated by RoostGPT for test pomXmlTest using AI Type Open AI and AI Model gpt-4

Scenario 1: Valid InjectionPoint
Given that the InjectionPoint is valid and the getMember method of the InjectionPoint returns a valid Member object, when the produceLogger method is called, then it should create a Logger object with the name of the class that declared the InjectionPoint.

Scenario 2: Invalid InjectionPoint
Given that the InjectionPoint is null, when the produceLogger method is called, then it should throw a NullPointerException.

Scenario 3: Invalid Member
Given that the getMember method of the InjectionPoint returns null, when the produceLogger method is called, then it should throw a NullPointerException.

Scenario 4: Nonexistent Class
Given that the getDeclaringClass method of the Member object returns a string that does not correspond to any class, when the produceLogger method is called, then it should throw a ClassNotFoundException.

Scenario 5: Class Without Package
Given that the getDeclaringClass method of the Member object returns a string that corresponds to a class that is not in a package, when the produceLogger method is called, then it should create a Logger object with the name of the class.

Scenario 6: Class In Package
Given that the getDeclaringClass method of the Member object returns a string that corresponds to a class that is in a package, when the produceLogger method is called, then it should create a Logger object with the name of the class including its package name.

Scenario 7: Multiple Calls to produceLogger
Given that the produceLogger method is called multiple times with the same InjectionPoint, then it should return the same Logger object each time.

Scenario 8: Different InjectionPoints for Same Class
Given that the produceLogger method is called with different InjectionPoints that belong to the same class, then it should return the same Logger object for each InjectionPoint. 

Scenario 9: Different InjectionPoints for Different Classes
Given that the produceLogger method is called with InjectionPoints that belong to different classes, then it should return different Logger objects for each InjectionPoint.
*/

// ********RoostGPT********
package org.agoncal.application.petstore.util;

import javax.enterprise.inject.spi.InjectionPoint;
import java.util.logging.Logger;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.BeforeEach;
import org.mockito.Mockito;
import java.lang.reflect.Member;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

public class LoggingProducer_produceLogger_0dae710c17_Test {

    private LoggingProducer loggingProducer;
    private InjectionPoint injectionPoint;

    @BeforeEach
    public void setup() {
        loggingProducer = new LoggingProducer();
        injectionPoint = mock(InjectionPoint.class);
    }

    @Test
    public void testProduceLogger_ValidInjectionPoint() {
        Member member = Mockito.mock(Member.class);
        when(injectionPoint.getMember()).thenReturn(member);
        when(member.getDeclaringClass()).thenReturn(this.getClass());

        Logger logger = loggingProducer.produceLogger(injectionPoint);
        assertEquals(this.getClass().getName(), logger.getName());
    }

    @Test
    public void testProduceLogger_NullInjectionPoint() {
        assertThrows(NullPointerException.class, () -> loggingProducer.produceLogger(null));
    }

    @Test
    public void testProduceLogger_NullMember() {
        when(injectionPoint.getMember()).thenReturn(null);
        assertThrows(NullPointerException.class, () -> loggingProducer.produceLogger(injectionPoint));
    }

    @Test
    public void testProduceLogger_ClassWithoutPackage() {
        Member member = Mockito.mock(Member.class);
        when(injectionPoint.getMember()).thenReturn(member);
        when(member.getDeclaringClass()).thenReturn(String.class);

        Logger logger = loggingProducer.produceLogger(injectionPoint);
        assertEquals(String.class.getName(), logger.getName());
    }

    @Test
    public void testProduceLogger_ClassInPackage() {
        Member member = Mockito.mock(Member.class);
        when(injectionPoint.getMember()).thenReturn(member);
        when(member.getDeclaringClass()).thenReturn(java.util.ArrayList.class);

        Logger logger = loggingProducer.produceLogger(injectionPoint);
        assertEquals(java.util.ArrayList.class.getName(), logger.getName());
    }

    @Test
    public void testProduceLogger_MultipleCalls() {
        Member member = Mockito.mock(Member.class);
        when(injectionPoint.getMember()).thenReturn(member);
        when(member.getDeclaringClass()).thenReturn(this.getClass());

        Logger logger1 = loggingProducer.produceLogger(injectionPoint);
        Logger logger2 = loggingProducer.produceLogger(injectionPoint);
        assertSame(logger1, logger2);
    }

    @Test
    public void testProduceLogger_DifferentInjectionPointsSameClass() {
        InjectionPoint injectionPoint2 = mock(InjectionPoint.class);
        Member member = Mockito.mock(Member.class);
        when(injectionPoint.getMember()).thenReturn(member);
        when(injectionPoint2.getMember()).thenReturn(member);
        when(member.getDeclaringClass()).thenReturn(this.getClass());

        Logger logger1 = loggingProducer.produceLogger(injectionPoint);
        Logger logger2 = loggingProducer.produceLogger(injectionPoint2);
        assertSame(logger1, logger2);
    }

    @Test
    public void testProduceLogger_DifferentInjectionPointsDifferentClass() {
        InjectionPoint injectionPoint2 = mock(InjectionPoint.class);
        Member member1 = Mockito.mock(Member.class);
        Member member2 = Mockito.mock(Member.class);
        when(injectionPoint.getMember()).thenReturn(member1);
        when(injectionPoint2.getMember()).thenReturn(member2);
        when(member1.getDeclaringClass()).thenReturn(this.getClass());
        when(member2.getDeclaringClass()).thenReturn(String.class);

        Logger logger1 = loggingProducer.produceLogger(injectionPoint);
        Logger logger2 = loggingProducer.produceLogger(injectionPoint2);
        assertNotSame(logger1, logger2);
    }
}
