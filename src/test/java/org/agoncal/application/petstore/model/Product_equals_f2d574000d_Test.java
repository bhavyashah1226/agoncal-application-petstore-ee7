// ********RoostGPT********
/*
Test generated by RoostGPT for test pomXmlTest using AI Type Open AI and AI Model gpt-4

1. Scenario: When the `product` object is compared with itself, the `equals` method should return `true`. This is because the `equals` method should be reflexive, meaning an object must equal itself.

2. Scenario: When the `product` object is compared with `null`, the `equals` method should return `false`. This is because no object is equal to `null`.

3. Scenario: When two `product` objects have the same `name` and `description`, the `equals` method should return `true`. This is to test the actual business logic of the `equals` method.

4. Scenario: When two `product` objects have the same `name` but different `description`, the `equals` method should return `false`. This is to test that both `name` and `description` must be equal for two `product` objects to be considered equal.

5. Scenario: When two `product` objects have different `name` but the same `description`, the `equals` method should return `false`. This is to test that both `name` and `description` must be equal for two `product` objects to be considered equal.

6. Scenario: When two `product` objects have different `name` and different `description`, the `equals` method should return `false`. This is to test that both `name` and `description` must be equal for two `product` objects to be considered equal.

7. Scenario: When a `product` object is compared with an object of a different class, the `equals` method should return `false`. This is to test the class check in the `equals` method.

8. Scenario: When a `product` object is compared with a subclass object, the `equals` method should return `false`. This is to test the class check in the `equals` method.
*/

// ********RoostGPT********
package org.agoncal.application.petstore.model;

import nl.jqno.equalsverifier.EqualsVerifier;
import org.junit.jupiter.api.Test;

public class Product_equals_f2d574000d_Test {

    @Test
    public void testEquals() {
        EqualsVerifier.forClass(Product.class)
                .withPrefabValues(Category.class, new Category("name1", "description1"), new Category("name2", "description2"))
                .verify();
    }

    @Test
    public void testEqualsForDifferentObjects() {
        Product product1 = new Product("Product1", "Description1", new Category("Category1", "Description1"));
        Product product2 = new Product("Product2", "Description2", new Category("Category2", "Description2"));

        assertNotEquals(product1, product2);
    }
}
